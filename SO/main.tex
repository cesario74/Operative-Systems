\documentclass{report}
\usepackage[utf8x]{inputenc}
\usepackage[portuges]{babel}
\usepackage{graphicx}
\usepackage{indentfirst}


\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\darius{\textsf{Darius}\xspace}
\def\antlr{\texttt{AnTLR}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}




\begin{figure}[t]
\centering
\includegraphics{miei}
\end{figure}
\title{Sistemas Operativos (2º\ ano de MIEI)\\ \textbf{Trabalho Prático  }\\ Relatório de Desenvolvimento}

\author{Cesário Miguel Pereira Perneta\\ (A73883) \and Luís Miguel Bravo Ferraz\\ (A70824) \and Pedro Miguel Lopes Pereira\\ (A70951) }

\date {\today }

\begin{document}
\maketitle

\begin{abstract}

\indent Este trabalho foi-nos proposto no âmbito da disciplina de Sistemas Operativos e tem como objetivo a construção de um sistema para processamento de \textit {notebooks}.

\indent No processamento, pressupõe-se que as linhas começadas por \$ sejam interpretas como comandos a serem executados, sendo o resultado desses comandos inserido imediatamente a seguir, delimitado por \textgreater\textgreater\textgreater e \textless\textless\textless.

\indent As linhas começadas por \$ \text{\textbar} executam comandos que têm como \textit {stdin} o resultado do comando anterior.

\end{abstract}

\tableofcontents
 \newpage
\chapter{Introducão}
\indent Neste trabalho foi-nos proposta a construção de um sistema para processamento de \textit {notebooks}, com vista em aumentar a nossa experiência no uso das matérias lecionadas ao longo deste semestre. O mesmo é composto por 3 diferentes etapas: interpretação dos comandos, execução dos mesmos e por ultimo, acrescentar o resultado da execução ao ficheiro.

\indent Em relação ás funcionalidades básicas, foram todas cumpridas com êxito, no entanto nas funcionalidades avançadas, apenas foi feito o primeiro ponto, acesso a resultados de comandos anteriores arbitrários.

\indent Esperamos com este relatório explicar e clarificar todas as decisões tomadas ao longo do trabalho bem como alcançar os objetivos traçados.



\newpage
\chapter{Contextualização}
Stream Processing é um sistema que utiliza uma rede de componentes para filtrar, processar e modicar um fluxo de eventos. Neste caso, pretende-se uma implementação para sistemas UNIX, explorando deste modo a semelhança de Stream Processing com filtros de texto compostos em pipeline.

\section{Eventos}
Um evento é uma linha de texto com campos separados entre ':'. Sõ estes eventos que vão ser filtrados e modificados pela rede de componentes.

\begin{verbatim}
a:20:c:30
b:3:f:56
d:5:j:23
v:32:y:7
\end{verbatim}

\section{Controlador}
O controlador será o programa que irá definir uma rede de processamento de streams, com cada nó a executar uma componente de transformação. Este controlador vai receber eventos por uma linha e os comandos poderão ser enviados mais tarde através de pipes com nome.

\section{Nós}
Um nó de processamento irá receber comandos e argumentos, e será com eles que vamos poder executar estes mesmos comandos de modo a iniciar as interações com outros nós. Para tal, um nó poderá usar mais que um processo e vários pipes.

\section{Conexões e Disconexões}
Os nós poderão estabelecer ligações entre si, isto é, será especificado que a saída da componente a correr no nó id deverá ser enviada para uma lista de outros nós. Será com as funçoes como o connect e o disconnect que se poderá iniciar ou terminar estas ligações.

\begin{verbatim}
connect 1 2 3 
disconnect 1 3
\end{verbatim}

\section{Inject}
A função inject será utilizada para injetar na entrada de um nó id a saída produzida por um comando depois de executado com uma lista de argumentos args.
\newpage
\chapter{Desenvolvimento}
\section{Estruturas}
\subsection{Controlador}
No Controlador, temos as seguintes estruturas:
\begin{itemize}
    \item A estrutura *Nodo, guarda a informação importante de um nó. O seu id, o comando, a lista de argumentos e o seu fifo de comunicação.
\begin{verbatim}
typedef struct nodo {
        int id;
        char* comando;
        char* args[1000];
        char* ponte;
} *Nodo;
\end{verbatim}
    \item A lista é, tal como o nome indica, a lista de nós no sistema.
\begin{verbatim}


Nodo *lista = malloc(sizeof(Nodo)*1024);
\end{verbatim}
    \item O num\_nodos é um inteiro que nos contabiliza o numero de nós no sistema. 
\begin{verbatim}
 int num_nodos = 0;
\end{verbatim}
    \item O buffer serve para guardar o que é lido nas conexoes.
\begin{verbatim}
\char buffer[1024];    
\end{verbatim}
\end{itemize}
\subsection{Nodo}
No Nodo, temos as seguintes estruturas:
\begin{itemize}
    \item O id\_ligacoes, vai ter, em cada posicao o id de um nó filho conectado a si proprio.
\begin{verbatim}
 int id_ligacoes[1024];
\end{verbatim}
    \item O array de Strings conexoes vai ter em cada posicao o fifo de conexao do nó conectado a ele. De reparar que o id guardado na posicao i do id\_ligacoes corresponde ao fifo guardado na posição i do conexoes.
\begin{verbatim}
char conexoes[1024][1024];
\end{verbatim}
    \item O buffer serve para guardar o que é lido nas conexoes.
\begin{verbatim}
char buffer[1024];    
\end{verbatim}
    \item O inteiro num\_connects vai contabilizando o numero de conexões de um nó.
\begin{verbatim}
    int num_connects=0;
\end{verbatim}
    \item O inteiro lixo, contabiliza o numero de nós com que houve disconexão.
\begin{verbatim}
int lixo = 0;
\end{verbatim}
\end{itemize}
\section{Implementação}
\subsection{Controlador-Nodo}

\subsubsection{Inicialização}
Este sistema implementado tem inicio na criação de nó. Esta criação é feita a partir de uma leitura do stdin. Quando este nó é criado, as suas componentes são guardadas na estrutura *Nodo, sendo que, após isto, é criado o seu fifo de conexão ao qual o servidor pode comunicar com ele, sendo este também guardado na estrutura. Este processo pode ser feito sempre que o utilizador assim o desejar.

\subsubsection{Conexão e Desconexão}
Assim que mais que um nó se encontra criada,pode-se começar então a estabelecer conexões entre os diversos nós. Sempre que é realizado um connect, por cada id secundário, é criado um novo fifo de conexão que vai permitir ambos os nós interagirem entre si. É possível também como já foi dito, realizar a ação inversa, desconectando os nós entre si.

\subsubsection{Interação}
Sempre que se realiza um inject, duas ações podem acontece:
\begin{itemize}
    \item Se um nó tiver associado nós secundários este vai enviar o output gerado para o input desses mesmos nós sendo que estes executam o mesmo processo que o seu nó pai.
    \item Por outro lado, se um nó não tiver nós filhos associados, ele envia esse mesmo output para um ficheiro único (id[id do nó].txt).
\end{itemize}
De forma a reforçar a ideia, é possível criar "grafos" entre nós, por exemplo, se um nó pai recebe um input, ele será imprimido só pelos últimos nós da cadeia.

\subsubsection{Apagar Nó}
Também é possível apagar um nó conectado ao sistema. Esta remoção processa-se por um "auto-envio" de um sinal utilizando a system call kill e o getpid().

\subsection{Funções}
É no functions,c que se encontram as funções a ser utilizadas pelos nós.

\newpage
\chapter{Conclusão}
Perante todas as dificuldades obtidas durante o trabalho, pensamos que os resultados obtidos são satisfatórios. Um pormenor a acrescentar é que ,inicialmente, as funções recebiam o nome de um ficheiro para ler, sendo que devia somente receber os argumentos necessários à sua realização. Só reparamos nesse facto no dia anterior à entrega, pelo que, só tivemos tempo de modificar a função constante, sendo que as outras estão funcionais se lhe passarmos o ficheiro, sendo necessário, para cumprir os objetivos, realizar as alterações nas outras funções realizadas na const.
Concluindo, apesar de todos os percalços, estamos contentes com o trabalho realizado.

\end{document}







